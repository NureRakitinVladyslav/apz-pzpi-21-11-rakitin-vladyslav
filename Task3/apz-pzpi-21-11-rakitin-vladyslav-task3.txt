1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Розроблювана програмна система має клієнт-серверну архітектуру, та складається з 4 компонентів: серверної – backend-частини, та 3 клієнтських –  iot-застосунок, веб-клієнт та мобільний додаток.
На стратегічному рівні взаємодія клієнтських та серверної частини відбувається наступним чином:
1) IoT частина та сервер
–	застосунок IoT зчитує показники положення тіла та температури військовослужбовців, математично їх оброблює та визначає стан військового;
–	ці дані передаються на сервер за допомогою захищеної передачі даних;
–	сервер обробляє ці дані, використовуючи алгоритми обробки користувацьких даних для визначення стану сну військовослужбовців та вжиття необхідних заходів.
2) Веб-частина та сервер
–	адміністратори веб-частини мають доступ до інструментів адміністрування для керування користувачами та налаштування системи;
–	сервер забезпечує інтерфейс для адміністраторів для управління базою даних та роботи з даними адміністраторів.
3) Мобільний додаток та сервер
–	військовослужбовець в мобільному додатку переглядає свій особистий профіль та дані про сон;
–	за допомогою мобільного додатку військовослужбовець може надсилати запити на ротацію;
–	сервер обробляє ці запити та надсилає сповіщення про них на мобільний додаток.
На технічному рівні взаємодія описується так:
1) IoT частина та сервер
–	застосунок IoT зчитує дані про положення тіла та температуру військовослужбовців;
–	ці дані передаються на сервер через HTTP POST запити з використанням захищеної передачі даних, наприклад, зашифрованого з'єднання HTTPS;
–	сервер приймає ці дані та обробляє їх, використовуючи власні алгоритми обробки користувацьких даних, щоб визначити стан сну військовослужбовців. Результати цієї обробки відправляються назад на IoT пристрій для відображення результату.
2) Веб-частина та сервер
–	адміністратори веб-частини взаємодіють з сервером через HTTP запити, наприклад, HTTP GET, POST, PUT або DELETE;
–	наприклад, коли адміністратор виконує пошук користувачів або редагує дані користувача, веб-інтерфейс відправляє відповідні HTTP запити на сервер;
–	сервер обробляє ці запити, виконує відповідні дії (наприклад, пошук або редагування даних) та повертає результати назад на веб-сторінку або веб-додаток через HTTP відповіді.
3) Мобільний додаток та сервер
–	коли військовослужбовець користується мобільним додатком, цей додаток взаємодіє з сервером через HTTP запити;
–	наприклад, при перегляді особистого профілю військовослужбовця, мобільний додаток відправляє запит на сервер за допомогою HTTP GET запиту, щоб отримати дані про сон;
–	сервер обробляє ці запити, виконує відповідні дії (наприклад, оновлення даних про ротацію) та відправляє сповіщення про результати операцій назад на мобільний додаток через HTTP відповіді або через пуш-сповіщення.

2 ОПИС АРХІТЕКТУРИ IOT-ЧАСТИНИ

IoT-частина програмної системи представляє з себе пристрій на основі ESP32, який збирає дані про положення тіла та температуру військовослужбовця і передає їх на сервер. Код для ESP32 написаний на мові програмування Arduino. Нижче наведені основні компоненти IoT-частини та їх функції: 
1) Мікроконтролер ESP32: Основний елемент IoT-пристрою, який виконує обробку даних з датчиків, зберігає проміжні дані та забезпечує підключення до мережі Інтернет для передачі даних на сервер.
2) Датчики: Пристрої, що використовуються для вимірювання кута нахилу тіла військовослужбовця та вимірювання температури тіла військовослужбовця.
3) Модуль WiFi: Вбудований модуль ESP32 для підключення до бездротової мережі та передачі даних на сервер.
Описані компоненти взаємодіють між собою наступним чином:
1) Мікроконтролер ESP32 зчитує дані з датчиків. Аналоговий вхід використовується для зчитування температури, тоді як цифрові входи використовуються для зчитування положення тіла за допомогою енкодера.
2) Датчик положення тіла передає інформацію про кут нахилу тіла мікроконтролеру через переривання.
3) Датчик температури передає показники температури тіла.
4) Мікроконтролер обробляє отримані дані для визначення поточного стану військовослужбовця (наприклад, спить чи ні, фаза сну).
5) Модуль WiFi в ESP32 забезпечує підключення до мережі.
6) Оброблені дані передаються на сервер за допомогою HTTP-запитів. Сервер отримує дані, обробляє їх і повертає відповідний статус. Мікроконтролер обробляє відповідь сервера для підтвердження успішної передачі даних або для повторної спроби у випадку помилки.

3 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Розроблювана програмна система призначена для 3 категорій користувачів (акторів):
1) Військовослужбовець
2) Командир
3) Адміністратор
Кожен з яких має наступні варіанти використання (прецеденти):
1) Військовослужбовець:
–	авторизація військовослужбовця
–	перегляд історії сну (extends авторизація військовослужбовця)
–	перегляд особистого профілю (extends перегляд історії сну)
–	зміна пароля військовослужбовця (extends перегляд особистого профілю)
–	оцінка сну (included перегляд історії сну)
–	перегляд історії ротацій (extends перегляд історії сну)
–	запит на ротацію (extends історія ротацій)
–	налаштування додатку (extends перегляд історії сну)
–	персоналізація мови (included налаштування додатку)
–	вибір формату часу (included налаштування додатку)
–	зміна порядку дній у календарі (included налаштування додатку)
2) Командир:
–	авторизація командира
–	перегляд особистого профілю (extends авторизація командира)
–	зміна пароля командира (extends перегляд особистого профілю)
–	перегляд списку підлеглих (extends авторизація командира)
–	управління підлеглими (included перегляд списку підлеглих)
–	встановлення звання підлеглого (included управління підлеглими)
–	перегляд історії сну підлегого (included управління підлеглими)
–	перегляд історії ротацій підлеглого (included управління підлеглими)
–	перегляд запитів на ротацію підлеглого (extends перегляд історії ротацій підлеглого)
–	ротація підлеглого (extends перегляд історії ротацій підлеглого)
3) Адміністратор:
–	авторизація адміністратора
–	управління підрозділами (extends авторизація адміністратора)
–	перегляд списку підрозділів (included управління підрозділами)
–	додавання підрозділів (included управління підрозділами)
–	редагування підрозділів (included управління підрозділами)
–	видалення підрозділів (included управління підрозділами)
–	управління командирами та військовими (included перегляд списку підрозділів)
–	перегляд списку командирів та військових (included управління командирами та військовими)
–	додавання командирів та військових (included управління командирами та військовими)
–	редагування командирів та військових (included управління командирами та військовими)
–	видалення командирів та військових (included управління командирами та військовими)
–	резервне копіювання даних
–	відновлення даних (extends Резервне копіювання даних)
–	маніпулювання даними
–	імпорт даних (included маніпулювання даними)
–	експорт даних (included маніпулювання даними)
За переліченими прецедентами можемо побудувати діаграму прецедентів для 3 акторів.

4 ПОБУДОВА ДІАГРАМИ ДІЯЛЬНОСТІ

Розглянуті 3 категорії користувачів виконують наступні діяльності, що послідовно переходять одна у одну наступним чином:
1) Початок: Система перебуває у початковому стані, жоден користувач не авторизований.
2) Авторизація: Кожен з користувачів (військовослужбовець, командир, адміністратор) вводить свої облікові дані. Якщо авторизація успішна, користувачі переходять до відповідних дій:
–	перегляд історії сну для військовослужбовця;
–	перегляд списку підлеглих для командира;
–	управління підрозділами для адміністратора.
3) Перегляд історії сну: Військовослужбовець переглядає свою історію сну. Командир переглядає історію сну підлеглих.
4) Управління підрозділами: Адміністратор переглядає список підрозділів, додає нові, редагує або видаляє існуючі підрозділи.
5) Запит на ротацію: Військовослужбовець після перегляду історії сну подає запит на ротацію.
6) Налаштування додатку: Військовослужбовець може налаштувати додаток, включаючи персоналізацію мови, вибір формату часу та зміну порядку дій у календарі.
7) Командир переглядає запит на ротацію: Командир переглядає запити на ротацію від підлеглих.
8) Перегляд списку підлеглих: Командир переглядає список підлеглих після авторизації.
9) Управління підлеглими: Командир управляє підлеглими:
–	встановлює звання підлеглого;
–	переглядає історію сну підлеглих;
–	переглядає історію ротацій підлеглих.
10) Управління списками: Адміністратор управляє списками підрозділів, командирів та військових:
–	переглядає список підрозділів, командирів або військових;
–	додає підрозділи, командирів або військових;
–	редагує підрозділи, командирів або військових;
–	видаляє підрозділи, командирів або військових;
11) Перегляд історії ротацій підлеглих: Командир переглядає історію ротацій підлеглих.
12) Перегляд запитів на ротацію: Командир переглядає запити на ротацію від підлеглих.
13) Ротація підлеглого: Командир здійснює ротацію підлеглого.
14) Військовослужбовець завершує ротацію: Військовослужбовець завершує процес ротації після виконання дій командира.
15) Кінець: Завершення діаграми діяльності, коли всі основні процеси виконані.
За описаним порядком діяльностей можна побудувати діаграму діяльності програмної системи.

5 ПОБУДОВА ДІАГРАМИ ВЗАЄМОДІЇ

До IoT-частини програмної системи можна віднести наступні об’єкти, що приймають участь у взаємодії: 
1) Користувач: Особа, яка носить на собі пристрій ESP32 із вбудованими датчиками.
2) Адміністратор: Особа, яка вводить ідентифікатор військовослужбовця у систему.
3) Мікроконтролер:  Вбудований пристрій на основі ESP32, який зчитує дані з датчиків і взаємодіє з сервером через WiFi.
4) WiFi модуль: Бездротовий модуль для забезпечення підключення ESP32 до мережі Інтернет.
5) Датчик температури тіла: Аналоговий датчик для вимірювання температури тіла військовослужбовця.
6) Датчик положення тіла: Цифровий датчик для визначення кута нахилу тіла військовослужбовця.
7) Сервер: Веб-сервер, який обробляє HTTP-запити та взаємодіє з базою даних.
Описані об’єкти взаємодіють наступним чином:
–	адміністратор вводить ідентифікатор військовослужбовця;
–	ESP32 отримує ідентифікатор від адміністратора;
–	ESP32 зчитує дані з датчика температури тіла і датчика положення тіла;
–	ESP32 створює HTTP-запит з даними про стан сну військовослужбовця;
–	WiFi модуль передає запит на сервер;
–	сервер приймає HTTP-запит від ESP32;
–	сервер оновлює базу даних та відправляє відповідь з результатом обробки у пристрій, що приймається через WiFi модуль;
–	ESP32 отримує відповідь від сервера про стан сну військовослужбовця;
–	ESP32 повертається до зчитування даних з датчиків після завершення обробки.
За переліченими об’єктами та їх взаємодіями можемо побудувати діаграму взаємодій.

6 ПОБУДОВА ДІАГРАМИ СТАНІВ

IoT-девайс програмної системи може перебувати у наступних станах, що послідовно переходять один у одний наступним чином:
1) Початок: Пристрій запускається і переходить до стану Ініціалізація.
2) Ініціалізація: Пристрій виконує початкові налаштування, налаштування пінів, підключення бібліотек та переходить до стану Підключення до WiFi.
3) Підключення до WiFi: Пристрій намагається підключитися до WiFi-мережі. Після успішного підключення переходить до стану Встановлення військового.
4) Встановлення військового: Адміністратор вводить ID військовослужбовця. Після введення ID пристрій переходить до стану Очікування подій.
5) Очікування подій: Пристрій очікує подій, таких як натискання кнопки ротатора або вимірювання. Можливі переходи до станів:
–	натискання кнопки;
–	регулярне вимірювання;
–	натискання кнопки.
6) Натискання кнопки: Користувач натискає кнопку ротатора. Пристрій переходить до стану Введення нового ID.
7) Введення нового ID: Користувач вводить новий ID військовослужбовця. Після введення ID пристрій повертається до стану Очікування подій.
8) Регулярне вимірювання: Пристрій виконує щосекундне зчитування даних з датчиків (температура тіла та положення тіла). Після зчитування пристрій повертається до стану Очікування подій.
9) Контрольний вимір: Пристрій виконує періодичне контрольне вимірювання (через певний інтервал часу). Переходить до стану Зчитування даних з датчиків.
10) Зчитування даних з датчиків: Пристрій зчитує дані з датчиків (температура тіла та положення тіла). Переходить до стану Аналіз даних та визначення фаз сну.
11) Аналіз даних та визначення фаз сну: Пристрій аналізує зчитані дані для визначення фази сну. Переходить до стану Визначення стану.
12) Визначення стану: Пристрій визначає, чи військовий спить, засинає або прокидається. Можливі переходи до станів:
–	військовий засинає;
–	військовий прокидається;
–	військовий не спить;
13) Військовий не спить: Пристрій фіксує, що військовий не спить. Переходить до стану Повторне вимірювання.
14) Військовий засинає: Пристрій фіксує, що військовий засинає. Переходить до стану Відправка HTTP запиту.
15) Військовий прокидається: Пристрій фіксує, що військовий прокидається. Переходить до стану Відправка HTTP запиту.
16) Повторне вимірювання: Пристрій виконує повторне зчитування даних у разі, якщо стан не змінився. Переходить до стану Очікування подій.
17) Відправка HTTP запиту: Пристрій відправляє HTTP-запит на сервер для оновлення стану сну військовослужбовця. Переходить до стану Очікування відповіді.
18) Очікування відповіді: Пристрій очікує відповіді від сервера після відправки HTTP-запиту. Переходить до стану Визначення стану.
19) Очікування подій: Повернення до основного стану очікування подій після завершення вимірювання або оновлення ID.
За наведеним переліком та описом станів можемо побудувати діаграму станів.

ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена IoT-частина для програмної системи проведення тренувань та оцінки їх результативності.

ДОДАТОК А
Програмний код IoT пристрою з коментарями

// Підключення додаткових файлів для забезпечення доступу в інтернет
#include <WiFi.h>
#include <HTTPClient.h>

// Встановлення макросів для портів
#define ENCODER_SW  13
#define ENCODER_CLK 14
#define ENCODER_DT  12
#define SENSOR 33

// Встановлення макросів для підключення до мережі
#define WIFI_SSID "Wokwi-GUEST"
#define WIFI_PASSWORD ""
#define WIFI_CHANNEL 6

// Встановлення глобальних констант
const int intervalTime = 6000;
const String endpoint = "http://host.wokwi.internal:5000/api/soldier/sleeps/update";

// Встановлення глобальних змінних
int soldierId = -1;
int rotateCounter = 0;
int intervalCounter = 0;
bool isSleeping = false;
int sleepPhase = 0;
float previousTemperature = NULL;

// Налаштування пристрою перед циклом
void setup() {
  Serial.begin(115200);
  // Пов'язування пристроїв з кодом
  analogReadResolution(10);
  pinMode(ENCODER_SW, INPUT_PULLUP);
  pinMode(ENCODER_CLK, INPUT);
  pinMode(ENCODER_DT, INPUT);
  pinMode(SENSOR, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCODER_CLK), onRotate, FALLING);
  // Підключення до інтернету
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);
  Serial.print("Встановлення сигналу...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print("...");
  }
  Serial.println(" Підключено!");
  // Встановлення військового
  setSoldierId();
}

// Безперервний цикл пристрою
void loop() {
  intervalCounter++;
  // Перевірка кнопки ротатора на натиснутість
  int buttonState = digitalRead(ENCODER_SW);
  if (buttonState == LOW) {
    setSoldierId();
  }
  // Зчитування значення сенсора температури
  int sensorValue = analogRead(SENSOR);
  float sensorTemperature = 1 / (log(1 / (1023. / sensorValue - 1)) / 3950 + 1.0 / 298.15) - 273.15;
  float rotationAngle = rotateCounter * 18.0;
  // Контрольний вимір
  if (intervalCounter >= intervalTime/1000) {
    intervalCounter = 0;
    Serial.println("-----------------");
    Serial.println("Контрольний вимір");
    // Повторне зчитування
    if (previousTemperature != NULL) {
      Serial.print("Температура тіла: ");
      // Температура збільшилася
      if (sensorTemperature > previousTemperature) {
        Serial.print("↑");
        Serial.print(sensorTemperature);
        Serial.print(" ℃ (на ");
        Serial.print(sensorTemperature - previousTemperature);
        Serial.print(" ℃ більше ніж ");
        Serial.print(intervalTime / 60000.0);
        Serial.println(" хвилин тому)");
      }
      // Температура не збільшилася
      else {
        Serial.print("↓");
        Serial.print(sensorTemperature);
        Serial.print(" ℃ (на ");
        Serial.print(abs(sensorTemperature - previousTemperature));
        Serial.print(" ℃ менше ніж ");
        Serial.print(intervalTime / 60000.0);
        Serial.println(" хвилин тому)");
      }
    }
    // Перше зчитування
    else {
      Serial.print("Температура тіла: ");
      Serial.print(sensorTemperature);
      Serial.println(" ℃ (немає попередніх даних)");
    }
    Serial.print("Кут нахила тіла: ");
    Serial.print(rotationAngle);
    // Військовий в лежачому положенні
    if (rotationAngle >= 60.0 || rotationAngle <= -60.0) {
      Serial.println("° (відповідає лежачому положенню)");
    }
    // Військовий в стоячому положенні
    else {
      Serial.println("° (відповідає стоячому положенню)");
    }
    Serial.print("Стан сну: ");
    // Якщо військовий вже спить
    if (isSleeping) {
      // Якщо військовий опинився в вертикальному положенні
      if (rotationAngle < 60.0 && rotationAngle > -60.0) {
        isSleeping = false;
        sleepPhase = 0;
        Serial.println("військовий прокинувся.");
        sendHTTP(false);
      }
      // Якщо військовий продовжив лежати
      else {
        Serial.println("продовжується.");
      }
    }
    // Якщо військовий ще не спить
    else {
      // Якщо військовий опинився в горизонтальному положенні
      if (rotationAngle >= 60.0 || rotationAngle <= -60.0) {
        // Якщо температура тіла зменшилася або залишилася незмінною
        if (sensorTemperature <= previousTemperature || previousTemperature == NULL) {
          Serial.print(sleepPhase);
          Serial.print(" → ");
          sleepPhase++;
          Serial.print(sleepPhase);
          Serial.print(" фаза сну.");
          // Якщо пройшов необхідний час для засинання
          if (sleepPhase == 5) {
            isSleeping = true;
            Serial.println(" Військовий заснув.");
            sendHTTP(true);
          }
          // Якщо ще не пройшов необхідний час для засинання
          else {
            Serial.println();
          }
        }
        // Якщо температура тіла збільшилася
        else {
          Serial.print(sleepPhase);
          Serial.print(" ← ");
          sleepPhase = 0;
          Serial.print(sleepPhase);
          Serial.println(" фаза сну.");
        }
      }
      // Якщо військовий продовжив стояти
      else {
        sleepPhase = 0;
        Serial.println("відсутній.");
      }
    }
    Serial.println("-----------------");
    previousTemperature = sensorTemperature;
  }
  // Звичайний вимір
  else {
    Serial.print("t = ");
    Serial.print(sensorTemperature);
    Serial.print(" ℃, ");
    Serial.print("α = ");
    Serial.print(rotationAngle);
    Serial.println("°");
  }
  // Затримка в 1 с перед наступним зчитуванням
  delay(1000);
}
// Метод відправки HTTP-запиту на сервер
void sendHTTP(bool start) {
  // Створення HTTP-клієнта
  HTTPClient http;
  String url = endpoint + "?start=" + (start == true ? "true" : "false") +
    "&soldierId=" + soldierId;
  http.addHeader("Content-Type", "text/plain");
  http.begin(url);
  Serial.println("Відправка даних на сервер...");
  // Відправка запиту на сервер
  int httpResponseCode = http.PUT("Sent from IOT Device");
  // Отримання відповіді
  if (httpResponseCode > 0) {
    // Успіх
    if (httpResponseCode == 200) {
      Serial.println("Історію сну успішно оновлено!");
    }
    // Некоректний запит
    else if (httpResponseCode == 400) {
      Serial.println("Помилка! Поточний стан військового не змінено.");
    }
    // Не знайдено
    else if (httpResponseCode == 404) {
      Serial.println("Помилка! Військового з встановленим ID не знайдено.");
      Serial.print("Оновіть дані. ");
      setSoldierId();
    }
    // Необроблена помилка
    else {
      Serial.print("Необроблена помилка ");
      Serial.println(httpResponseCode);
    }
  }
  // Відсутність відповіді
  else {
    Serial.println("Помилка! Відсутній зв'язок з сервером!");
  }
  // Завершення процедури
  http.end();
}
// Зміна куту нахилу військового
void onRotate() {
  // Зчитування напрямку нахилу
  int direction = digitalRead(ENCODER_DT);
  // Вправо
  if (direction == HIGH) {
    rotateCounter++;
  }
  // Вліво
  if (direction == LOW) {
    rotateCounter--;
  }
}

// Встановлення ID військового
void setSoldierId() {
  Serial.print("Введіть ID військового: ");
  Serial.read();
  while(!Serial.available()) {
    delay(1);
  }
  // Зчитування значення з клавіатури
  soldierId = Serial.parseInt() ;
  Serial.println(soldierId);
  Serial.println("ID військового успішно встановлено!");
}
